<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Daddy‚Äôs Spotify Player üöÄ</title>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Styles remain the same as the previous version */
        :root {
            --bg: #0a0a0a;
            --fg: #e0e0e0;
            --accent: #ff007f; /* Bright Pink */
            --accent-dim: rgba(255, 0, 127, 0.2);
            --bg-image: url(''); /* Will be set by JS */
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: 'Orbitron', sans-serif; background: var(--bg); color: var(--fg);
            display: flex; flex-direction: column; height: 100vh; overflow: hidden;
        }
        body::before {
            content: ''; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-image: var(--bg-image), radial-gradient(circle at top left, var(--accent), #000);
            background-size: cover;
            filter: blur(30px) brightness(0.3);
            z-index: -1;
            transition: background-image 1s ease-in-out;
        }
        @keyframes flicker { 0%, 18%, 22%, 25%, 53%, 57%, 100% { opacity: 1 } 20%, 24%, 55% { opacity: 0.5 } }
        h1 {
            text-align: center; margin: 1rem 0; text-shadow: 0 0 8px var(--accent);
            animation: flicker 3s infinite;
        }
        #status { text-align: center; margin-bottom: .5rem; min-height: 1.2em; }
        #login {
            align-self: center; background: var(--accent); color: var(--bg); border: none;
            padding: .75rem 1.5rem; border-radius: 4px; cursor: pointer;
            text-transform: uppercase; font-weight: bold; box-shadow: 0 0 12px var(--accent);
            margin-bottom: 1rem;
        }
        #controls {
            display: flex; justify-content: center; flex-wrap: wrap; gap: .5rem;
            padding: .75rem; background: rgba(0, 0, 0, 0.5); margin: .5rem 1rem;
            border-radius: 6px; box-shadow: 0 0 12px var(--accent);
        }
        #controls button {
            background: var(--accent-dim); border: 1px solid var(--accent);
            color: var(--fg); padding: .5rem 1rem; border-radius: 4px;
            cursor: pointer; transition: transform .2s, background .2s, box-shadow .2s;
        }
        #controls button:disabled { cursor: not-allowed; opacity: 0.5; }
        #controls button.active {
            background: var(--accent); color: var(--fg);
            box-shadow: 0 0 12px var(--accent);
        }
        #controls button:not(:disabled):hover { transform: scale(1.1); }
        #controls button:not(:disabled):active {
            background: var(--accent) !important;
            color: var(--fg) !important;
            box-shadow: 0 0 12px var(--accent);
            transform: scale(0.95);
        }
        #nowPlaying {
            display: flex; align-items: center; gap: 1rem; padding: 1rem;
            background: rgba(0, 0, 0, 0.6); margin: 0 1rem .5rem; border-radius: 6px;
            box-shadow: 0 0 12px var(--accent); min-height: 100px;
        }
        #nowPlaying img {
            width: 80px; height: 80px; border-radius: 4px;
            box-shadow: 0 0 12px var(--accent); object-fit: cover;
        }
        #nowInfo { display: flex; flex-direction: column; justify-content: center; }
        #nowInfo div { margin: .25rem 0; }
        .container {
            display: grid; grid-template-columns: 1fr 2fr; flex: 1; overflow: hidden;
            gap: 1rem; padding: 0 1rem 1rem;
        }
        #playlistSection, #trackSection {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 6px; overflow-y: auto;
            padding: 1rem; box-shadow: 0 0 12px var(--accent);
            scrollbar-width: thin;
            scrollbar-color: var(--accent) var(--accent-dim);
        }
        #playlistSection::-webkit-scrollbar, #trackSection::-webkit-scrollbar { width: 8px; }
        #playlistSection::-webkit-scrollbar-track, #trackSection::-webkit-scrollbar-track { background: var(--accent-dim); border-radius: 4px;}
        #playlistSection::-webkit-scrollbar-thumb, #trackSection::-webkit-scrollbar-thumb { background-color: var(--accent); border-radius: 4px; border: 2px solid var(--accent-dim);}

        #playlistSection ul, #trackSection ul { list-style: none; }

        @keyframes fadeIn { to { opacity: 1 } }
        @keyframes glow {
            0%, 100% { box-shadow: 0 0 12px var(--accent) }
            50% { box-shadow: 0 0 20px var(--accent) }
        }

        #playlistSection li, #trackSection li {
            display: flex; align-items: center; gap: .5rem; padding: .5rem;
            border-bottom: 1px solid var(--accent-dim); cursor: pointer; opacity: 0;
            animation: fadeIn .3s forwards;
            transition: background-color 0.2s ease;
        }
        #playlistSection li:last-child, #trackSection li:last-child { border-bottom: none; }

        #playlistSection li.selected,
        #trackSection li.playing {
            background: var(--accent) !important;
            color: var(--fg) !important;
            animation: glow 1.5s infinite; /* Glow re-enabled */
            opacity: 1 !important;
        }

        #playlistSection img { width: 40px; height: 40px; border-radius: 4px; flex-shrink: 0; }
        #trackSection header {
            display: flex; justify-content: space-between;
            align-items: center; margin-bottom: .5rem;
        }
        #trackSection select {
            background: var(--accent-dim); border: 1px solid var(--accent);
            padding: .25rem; color: var(--fg); border-radius: 4px;
            cursor: pointer; font-family: inherit;
        }
        #playlistSection li:hover,
        #trackSection li:hover {
            background: var(--accent-dim);
        }
        #playlistSection li.selected:hover,
        #trackSection li.playing:hover {
             background: var(--accent) !important;
        }
        #playlistSection li:active,
        #trackSection li:active {
            background: var(--accent);
            color: var(--fg);
            animation: none;
        }
    </style>
</head>
<body>
    <h1>Daddy‚Äôs Spotify Player üöÄ</h1>
    <div id="status">Not logged in</div>
    <button id="login">Log in with Spotify</button>

    <div id="controls">
        <button id="prevBtn" disabled>‚èÆÔ∏è Prev</button>
        <button id="playPauseBtn" disabled>‚ñ∂Ô∏è Play/Pause</button>
        <button id="nextBtn" disabled>‚è≠Ô∏è Next</button>
        <button id="shuffleBtn" disabled>üîÄ Shuffle</button>
        <button id="repeatBtn" disabled>üîÅ Repeat</button>
    </div>

    <div id="nowPlaying">
        <img id="trackArt" src="" alt="Album Art">
        <div id="nowInfo">
            <div id="trackInfo">Not playing</div>
            <div id="nextTrack"></div>
        </div>
    </div>

    <div class="container">
        <div id="playlistSection">
            <h2>Playlists</h2>
            <ul id="playlists"></ul>
        </div>
        <div id="trackSection">
            <header>
                <h2>Tracks</h2>
                <select id="sortSelect">
                    <option value="custom">API Order</option>
                    <option value="newest">Date Added ‚Üì</option>
                    <option value="oldest">Date Added ‚Üë</option>
                </select>
            </header>
            <ul id="tracks"></ul>
        </div>
    </div>

    <script>
        // PKCE + API helpers...
        const client_id = 'b00e3fe2a9394a86a64048c96a3ff5f3';
        const redirect_uri = 'https://pyromonkey007.github.io/Spotify/';
        const scopes = [
            'streaming', 'user-read-private', 'user-read-email',
            'user-read-playback-state', 'user-modify-playback-state',
            'playlist-read-private', 'playlist-read-collaborative'
        ].join(' ');
        const STATE_KEY = 'spotify_pkce_state', VERIFIER_KEY = 'spotify_pkce_verifier';
        let access_token, player, currentPlaylistId;
        // Initialize playlistItems as empty array
        let playlistItems = [];

        // PKCE Helper Functions (Unchanged)
        function randStr(l){ const c='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'; let s='',a=new Uint8Array(l);crypto.getRandomValues(a); a.forEach(i=>s+=c[i%c.length]);return s; }
        function b64url(b){ return btoa(String.fromCharCode(...new Uint8Array(b))).replace(/=+$/,'').replace(/\+/g,'-').replace(/\//g,'_'); }
        async function sha256(m){ return crypto.subtle.digest('SHA-256', new TextEncoder().encode(m)); }

        // API Helper (Unchanged)
        async function api(path, opts = {}) {
            const base_url = 'https://api.spotify.com/v1';
            // Ensure access token is available
            if (!access_token) {
                 console.error("API call attempted without access token for path:", path);
                 status("‚ùå Error: Not Logged In");
                 return null; // Prevent API call without token
            }
            opts.headers = { ...(opts.headers || {}), 'Authorization': 'Bearer ' + access_token };
            try {
                const res = await fetch(base_url + path, opts);
                if (!res.ok) {
                    const errorBodyText = await res.text().catch(() => 'Could not read error body');
                    console.error(`API Error ${res.status} on ${path}:`, errorBodyText);
                    let errorJson = {}; try { errorJson = JSON.parse(errorBodyText); } catch { /* ignore */ }
                    // Check for common errors like expired token
                    if (res.status === 401 || errorJson?.error?.message?.includes("token expired")) {
                         status("‚ùå Error: Token Expired. Please log in again.");
                         // Optionally trigger re-authentication or show login button
                         document.getElementById('login').style.display = 'block';
                    } else {
                         status(`‚ùå API Error: ${errorJson?.error?.message || res.status}`);
                    }
                    throw new Error(errorJson?.error?.message || `Spotify API Error: ${res.status}`);
                }
                if (res.status === 204 || res.headers.get('content-length') === '0') { return { success: true }; }
                return await res.json();
            } catch (error) {
                console.error(`Workspace failed for ${path}:`, error);
                // Status is already set in the error handling above or if fetch itself failed
                if (!document.getElementById('status').textContent.startsWith('‚ùå')) {
                    status(`‚ùå Network Error for ${path}`);
                }
                return null;
            }
        }
        function status(msg) { document.getElementById('status').textContent = msg; }

        // Auth Functions (Unchanged)
        async function redirectToAuth(){ const state=randStr(16),ver=randStr(64); sessionStorage.setItem(STATE_KEY,state); sessionStorage.setItem(VERIFIER_KEY,ver); const chall=b64url(await sha256(ver)); const p=new URLSearchParams({ response_type:'code',client_id,redirect_uri,scope:scopes, state,code_challenge_method:'S256',code_challenge:chall,show_dialog:'true' }); window.location=`https://accounts.spotify.com/authorize?${p.toString()}`; }
        async function handleRedirect(){ const qs=new URLSearchParams(window.location.search), code=qs.get('code'),state=qs.get('state'),error=qs.get('error'); if(error){ status(`‚ùå Login Error: ${error}`); sessionStorage.removeItem(STATE_KEY); sessionStorage.removeItem(VERIFIER_KEY); return; } if(!code){ return; } const storedState=sessionStorage.getItem(STATE_KEY); const verifier=sessionStorage.getItem(VERIFIER_KEY); if(state!==storedState||!verifier){ status('‚ùå State mismatch/verifier missing'); sessionStorage.removeItem(STATE_KEY); sessionStorage.removeItem(VERIFIER_KEY); history.replaceState(null,'',redirect_uri); return; } sessionStorage.removeItem(STATE_KEY); sessionStorage.removeItem(VERIFIER_KEY); const body=new URLSearchParams({ grant_type:'authorization_code',code,redirect_uri, client_id,code_verifier:verifier }); try { const tok=await fetch('https://accounts.spotify.com/api/token',{ method:'POST',headers:{'Content-Type':'application/x-www-form-urlencoded'},body }).then(async r=>{ if(!r.ok){ const e=await r.json().catch(()=>({error_description:'Unknown token error'})); throw new Error(e.error_description||`Token fetch failed: ${r.status}`); } return r.json(); }); if(!tok.access_token){ status('‚ùå Token failed'); return; } access_token=tok.access_token; history.replaceState(null,'',redirect_uri); status('‚úÖ Logged in'); document.getElementById('login').style.display='none'; await initApp(); } catch(err){ console.error('Error fetching token:',err); status(`‚ùå Token failed: ${err.message}`); } }

        // Init Application
        async function initApp() {
            ['prevBtn', 'playPauseBtn', 'nextBtn', 'shuffleBtn', 'repeatBtn']
                .forEach(id => document.getElementById(id).disabled = false);

            document.getElementById('prevBtn').onclick = () => player?.previousTrack().catch(console.error);
            document.getElementById('nextBtn').onclick = () => player?.nextTrack().catch(console.error);
            document.getElementById('playPauseBtn').onclick = () => player?.togglePlay().catch(console.error);
            document.getElementById('shuffleBtn').onclick = toggleShuffle;
            document.getElementById('repeatBtn').onclick = toggleRepeat;
            document.getElementById('sortSelect').onchange = renderTracks;

            document.getElementById('playlists').innerHTML = '<li>Loading playlists...</li>';
            await loadPlaylists();
            // No call to loadFeaturedPlaylists()
            loadSDK();
        }

        // Library Loading (Loads ONLY User Playlists - Unchanged)
        async function loadPlaylists() { const ul=document.getElementById('playlists'); ul.innerHTML='<li>‚è≥ Loading your playlists...</li>'; let url='/me/playlists?limit=50'; let allPlaylists=[]; let fetchedCount=0; const maxPlaylistsToFetch=200; try { while(url&&fetchedCount<maxPlaylistsToFetch){ const dat=await api(url); if(dat===null)break; if(!dat||!dat.items){ break; } allPlaylists.push(...dat.items); fetchedCount+=dat.items.length; url=dat.next?dat.next.replace('https://api.spotify.com/v1',''):null; } ul.innerHTML=''; if(allPlaylists.length===0){ ul.innerHTML='<li>No playlists found.</li>'; }else{ allPlaylists.forEach(pl=>{ const li=document.createElement('li'); li.dataset.id=pl.id; const img=document.createElement('img'); img.src=pl.images?.[0]?.url||'placeholder.png'; img.alt=pl.name; img.loading='lazy'; li.appendChild(img); li.appendChild(document.createTextNode(pl.name)); li.onclick=()=>loadTracks(pl.id); ul.appendChild(li); }); } } catch(e){ console.error("Error during playlist loading loop:",e); ul.innerHTML='<li>Error loading playlists.</li>'; } }

        // --- Track Loading & Rendering ---
        // --- UPDATED loadTracks to handle pagination ---
        async function loadTracks(id) {
            currentPlaylistId = id;
            document.querySelectorAll('#playlists li').forEach(li =>
                li.classList.toggle('selected', li.dataset.id === id)
            );
            status(`‚è≥ Loading tracks (0)...`); // Initial status
            const ul = document.getElementById('tracks');
            ul.innerHTML = '<li>‚è≥ Loading tracks...</li>';

            // Reset playlistItems for the new playlist
            playlistItems = [];
            let fetchedCount = 0;
            // Initial URL for the first batch of tracks (max 100)
            // Request needed fields: added_at for sorting, track details for display/playback
            let url = `/playlists/${id}/tracks?limit=100&fields=next,items(added_at,track(name,uri,artists(name),album(images)))`;

            try {
                while (url) {
                    const data = await api(url); // Fetch a page of tracks
                    if (data === null) { // API call failed
                        ul.innerHTML = '<li>‚ùå Failed to load tracks.</li>';
                        renderTracks(); // Render empty state if possible
                        return; // Stop loading this playlist
                    }

                    // Process valid items
                    const validItems = (data.items || [])
                        .filter(item => item && item.track) // Filter out items with null track
                        .map(i => ({ track: i.track, added_at: i.added_at }));

                    playlistItems.push(...validItems); // Append new tracks to the list
                    fetchedCount += validItems.length;
                    status(`‚è≥ Loading tracks (${fetchedCount})...`); // Update loading status

                    // Prepare URL for the next page, making it relative for the api helper
                    url = data.next ? data.next.replace('https://api.spotify.com/v1', '') : null;
                } // End while loop

                status(`‚úÖ Tracks loaded (${playlistItems.length} items).`); // Final status
                renderTracks(); // Render all fetched tracks

            } catch (e) {
                // Error should have been handled by api() helper, but catch unexpected ones
                console.error("Error during track loading loop:", e);
                ul.innerHTML = '<li>‚ùå Error loading tracks.</li>';
                playlistItems = []; // Clear potentially partial list
                renderTracks(); // Render empty state
            }
        }

        // Render Tracks (Unchanged - renders based on the now complete playlistItems)
        function renderTracks() {
             const mode=document.getElementById('sortSelect').value;
             // Use the globally stored playlistItems which is now fully populated
             let arr=[...playlistItems];
             const ul=document.getElementById('tracks');
             ul.innerHTML='';
             if(arr.length===0){
                 ul.innerHTML='<li>No tracks found or loaded.</li>'; // Adjusted message
                 return;
             }
             try {
                 if(mode==='newest')arr.sort((a,b)=>(new Date(b.added_at).getTime()||0)-(new Date(a.added_at).getTime()||0));
                 if(mode==='oldest')arr.sort((a,b)=>(new Date(a.added_at).getTime()||0)-(new Date(b.added_at).getTime()||0));
             } catch(e){ console.warn("Error sorting tracks by date:",e); }
             arr.forEach((obj,index)=>{
                 if(!obj?.track?.artists){ console.warn("Skipping invalid track object:",obj); return; }
                 const li=document.createElement('li');
                 li.dataset.uri=obj.track.uri;
                 li.textContent=`${obj.track.name} ‚Äî ${obj.track.artists.map(a=>a.name).join(', ')}`;
                 li.style.animationDelay=`${index*30}ms`;
                 // Pass index relative to the *final, sorted* array being rendered
                 li.onclick=()=>playTrack(obj.track.uri, index);
                 ul.appendChild(li);
             });
         }

        // Play Track (Unchanged - plays based on index in current rendered list)
        function playTrack(uri, index) {
            if (!player || !currentPlaylistId) {
                status("Player not ready or no playlist selected.");
                return;
            }
            status("‚ñ∂Ô∏è Requesting track...");
            console.log(`Requesting Play: Playlist ${currentPlaylistId}, Track URI ${uri}, Index ${index}`);
            // Important: The 'index' here corresponds to the position in the currently rendered list
            // (which might be sorted differently from the original API order).
            // Using context_uri + offset should work correctly regardless of client-side sorting.
            api('/me/player/play', {
                method: 'PUT',
                body: JSON.stringify({
                    context_uri: `spotify:playlist:${currentPlaylistId}`,
                    offset: { position: index } // Offset is relative to the playlist's context on Spotify
                })
            }).then(response => {
                 if (response === null) { status("‚ùå Play command failed (API error)."); }
             }).catch(err => {
                 console.error("Network/fetch error sending play command:", err);
                 status("‚ùå Play command failed (Network error).");
             });
        }

        // Web Playback SDK Initialization and Listeners (Unchanged - includes status updates)
        function loadSDK() {
             if (document.querySelector('script[src="https://sdk.scdn.co/spotify-player.js"]') || window.Spotify?.Player) { if (player&&typeof player.connect==='function'&&!player.isConnected?.()) { player.connect().catch(console.error); } return; }
            const s=document.createElement('script'); s.src='https://sdk.scdn.co/spotify-player.js'; s.async=true; document.head.appendChild(s);
            window.onSpotifyWebPlaybackSDKReady = () => {
                 status("üöÄ SDK Ready, initializing player...");
                player = new Spotify.Player({ name: 'Daddy‚Äôs Spotify Player üöÄ', getOAuthToken: cb => cb(access_token), volume: 0.5 });
                ['initialization_error', 'authentication_error', 'account_error', 'playback_error']
                    .forEach(evt => player.addListener(evt, ({ message }) => { console.error(`SDK ${evt}:`, message); status(`‚ùå SDK Error: ${evt}`); if (evt === 'authentication_error') { document.getElementById('login').style.display='block'; access_token=null; ['prevBtn','playPauseBtn','nextBtn','shuffleBtn','repeatBtn'].forEach(id=>document.getElementById(id).disabled=true); } if (evt === 'account_error') { alert("Spotify Premium required."); } }));
                player.addListener('ready', ({ device_id }) => { console.log('SDK Player Ready', device_id); status('üéß Device Ready, selecting...'); api('/me/player', { method:'PUT', body: JSON.stringify({ device_ids: [device_id], play: false }) }).then(r => { if (r?.success) status('üéß Device Ready & Selected'); else status('‚ö†Ô∏è Device Ready, failed select.'); }).catch(()=>{}); });
                player.addListener('not_ready', ({ device_id }) => { console.log('Device Offline', device_id); status('üîå Device Offline'); });
                player.addListener('player_state_changed', (st) => {
                     console.log("Player state changed:", st);
                    if (!st) { status('‚ÑπÔ∏è Player state unavailable (Inactive)'); document.getElementById('playPauseBtn').textContent='‚ñ∂Ô∏è Play/Pause'; document.getElementById('trackArt').src=''; document.getElementById('trackInfo').textContent='Not playing'; document.getElementById('nextTrack').textContent=''; document.body.style.setProperty('--bg-image',''); document.querySelectorAll('#tracks li.playing').forEach(li => li.classList.remove('playing')); return; }
                    if (st.paused) { status("‚è∏Ô∏è Paused"); } else { status("‚ñ∂Ô∏è Playing"); }
                    const t = st.track_window.current_track; const next = st.track_window.next_tracks[0];
                    if (t) { document.getElementById('trackArt').src = t.album.images[0]?.url || 'placeholder.png'; document.body.style.setProperty('--bg-image', `url(${t.album.images[0]?.url})`); document.getElementById('trackInfo').textContent = `${t.name} ‚Äî ${t.artists.map(a => a.name).join(', ')}`; } else { document.getElementById('trackArt').src = ''; document.getElementById('trackInfo').textContent = 'No track loaded'; document.body.style.setProperty('--bg-image', ''); }
                    document.getElementById('nextTrack').textContent = next ? `Next ‚ûú ${next.name}` : '';
                    document.getElementById('playPauseBtn').textContent = st.paused ? '‚ñ∂Ô∏è Play' : '‚è∏Ô∏è Pause'; document.getElementById('shuffleBtn').classList.toggle('active', st.shuffle); const repeatMode = st.repeat_mode; document.getElementById('repeatBtn').classList.toggle('active', repeatMode !== 0); repIdx = repeatMode; document.getElementById('prevBtn').disabled = !st.track_window.previous_tracks.length; document.getElementById('nextBtn').disabled = !st.track_window.next_tracks.length;
                    document.querySelectorAll('#tracks li').forEach(li => { const isPlaying = t && li.dataset.uri === t.uri; li.classList.toggle('playing', isPlaying); });
                });
                status("üîå Connecting player...");
                player.connect().then(success => { if(success){ console.log('SDK connected!'); status('üîó SDK Connected'); } else { console.error('SDK failed connect.'); status('‚ùå SDK Connect Fail'); } }).catch(err => { console.error("Player connect error:", err); status('‚ùå SDK Connect Error'); });
            };
        }

        // Control Button Helpers (Unchanged)
        async function updateShuffleRepeat(){ try { const st=await api('/me/player'); if(st&&typeof st.shuffle_state!=='undefined'){ document.getElementById('shuffleBtn').classList.toggle('active',st.shuffle_state); const crs=st.repeat_state||'off'; document.getElementById('repeatBtn').classList.toggle('active',crs!=='off'); repIdx=repStates.indexOf(crs); if(repIdx===-1)repIdx=0; } } catch(e){} }
        async function toggleShuffle(){ try { const btn=document.getElementById('shuffleBtn'); const newState=!btn.classList.contains('active'); const r=await api(`/me/player/shuffle?state=${newState}`,{method:'PUT'}); if(r){ btn.classList.toggle('active',newState); /* Status updated by player_state_changed */ } } catch(e){} }
        const repStates=['off','context','track']; let repIdx=0;
        async function toggleRepeat(){ try { repIdx=(repIdx+1)%3; const newState=repStates[repIdx]; const r=await api(`/me/player/repeat?state=${newState}`,{method:'PUT'}); if(r){ document.getElementById('repeatBtn').classList.toggle('active',newState!=='off'); /* Status updated by player_state_changed */ } } catch(e){} }

        // Global Unhandled Rejection Handler (Unchanged)
        window.addEventListener('unhandledrejection',e=>{ if(e.reason&&e.reason.name==='CloudPlaybackClientError'){ e.preventDefault(); console.warn('Ignored CloudPlaybackClientError:',e.reason.message); }else{ console.error("Unhandled Rejection:",e.reason||e); status("‚ö†Ô∏è Unexpected error."); } });

        // Initial Setup (Unchanged)
        document.getElementById('login').onclick = redirectToAuth;
        window.addEventListener('load', handleRedirect);

    </script>
</body>
</html>
